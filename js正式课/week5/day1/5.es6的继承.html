<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
<script>
    /*
    * es6中的继承
    * class
    * */
    function Parent() {
        this.name = 'zf';
    }

    Parent.prototype.getX = function () {
        return this.name
    };
    new Parent();
    Parent.a = function () {
    }  //把parent当做一个对象


    //通过es6的方式来创建
   /* class Child {
        constructor() {
            //都是子类的私有属性和方法
            this.age = 8
        }

        //子类的公有属性和方法
        getY() {
            return this.age
        }

        //把Child当做一个对象来用，在对象中扩展一个属性b
        static b() {
            return this
        }
    }*/


    //将子类Child继承父类Parent，通过关键字extents来实现,把父类的私有属性和公有属性都继承过来
    class Child extends Parent {
        //想在子类中添加私有属性【必须添加super】
        constructor() {
            //子类继承父类之后，子类中的私有属性可以不用加，如果加了，必须添加super()，让其执行
            //继承过后，首先应该写super，不可以在super上给this赋值
           super()  //就算Parent的私有属性，如果添加constructor，必须添加super，否则会报错
            //this.name= 'china'
        }
    }

    console.dir(new Child());


    /*
    * es6中的继承就是es5我们说的寄生组合继承，通过extents 继承父类的私有属性和公有属性，如果有添加constructor函数的话，我们必须添加super，不然会报错，super就属于call继承，可以通过super给父类传参。除此之外都是公有属性。子类的公有属性通过原型链_ _proto_ _可以找到父类的公有属性【constructor没有丢失】
    *
    * */

    /*
    * 在继承当中，我们可以通过原型继承、寄生组合继承，可以修改父类上面的属性和方法，这种方式属于重写，【重写：重新修改父类上的方法通过继承】
    *
    * */
</script>