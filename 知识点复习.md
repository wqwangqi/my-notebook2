##知识点复习

###一：数组的方法
1.includes：返回是布尔值

2.find :找到返回的那一项，不会改变原数组，回调函数中返回true表示找到了，找到后停止，如果没有找到返回undefined；它是找到具体的某一项


let ary = [1,2,3,4,55]
let result = ary.find(function(){
	return item.toString().indexof(5)>-1
});
console.log(result);  // 55

3.some: 找true 找到true后停止 ，返回true ，找不到返回false，返回是一个布尔值
4.every: 找false 找到false后停止，返回false，返回是一个布尔值

5.reduce:收敛  4个参数，返回的是叠加后的结果，原数组不发生改变
[1,2,3,4,5].reduce(function(prev,next,index,item){
    console.log(prev,next);   // 1 2   100 3   100 4   100 5
    return 100;   //本次的返回值 ，会作为下一次的prev
    <!-- 想要求和的话  return prev+next -->
})

let sum = [{price:30,count:2},{price:30,count:3},{price:30,count:4}].reduce(function(prev,next){
     // 0+60
     // 60+90
     // 150+120
     return prev+next.prev*next.count
},0);  //0表示默认指定第一次的prev
console.log(sum); //270  

let sum2 = [[1,2,3],[4,5,6],[7,8,9]].reduce(function(prev,next){
    return prev.concat(next);
});
console.log(sum2);



###二：箭头函数
改变this的指向：
1.call apply bind
2.var that = this
3.箭头函数

箭头函数：不具备this和arguments
funciton a(b){
    return b+1
};   //普通函数

let a = b => b+1;  //去掉function关键字，参数有一个的话，可以省略小括号，小括号和大括号之间有一个箭头，如果没有大括号，则直接是返回值，有大括号必须有return

把普通函数变成箭头函数eg:
function a(b){
    return function (c){
        return b+c;
    }
}
a(1)(2);   

let a = b => c => b+c;  //高阶函数（>=2个箭头的）
a(1)(2)

闭包：函数执行的一瞬间叫做闭包，(不销毁的作用域)，当执行后返回的结果必须是引用数据类型，被外界变量接收，此时这个函数不会被销毁


###三：vue认识

vuex  数据管理    
vue-cli 构建工具

MVC（backbone）  单向的
- model 数据
- view 视图
- comtroller  控制器

用户输入->controller->model(到数据库获取数据)->view视图 ->用户得到反馈    它形成一个闭环

MVVM（angular，vue） 双向的
- model 数据
- view 视图
- viewModel 视图模式

数据可以影响视图，视图也可以影响数据     


jq操作的是真实的dom，vue操作的是虚拟的dom
路由：hash和histroy （单页面应用开发）  路由传参[/:id,params,query]

webpack：打包工具  node



###四：面向对象：类的继承封装和多态
- 封装：
    - 把实现一个js代码代码进行封装，主要目的：“低耦合高内聚”
- 多态
    - 重载：方法名相同，参数的个数或者类型不同，此时名字相同的方法叫做方法的重载（后台语言中的重载），js中不存在重载
    - 重写：子类重写父类的方法
- 继承：
    子类继承父类的属性和方法
    - 原型继承:让子类的原型指向父类的一个实例（让父类的私有和公有变成子类的公有）
    - call继承:让父类的私有变成子类的私有
    - 寄生组合继承(es5)：父类的私有变为子类的私有，父类的公有变为子类的公有
    - es6中class继承 
     ```原型继承：让子类的原型执行父类的一个实例
        function A(){
            this.x = 100;
        }
        A.prototype = {
            constructor:A,
            getX:function(){
                console.log(this.x)
            }
        };
        function B(){
            this.y = 200;
        }
        B.prototype = new A();
        let f = new B()

        原型继承和传统后台语言的继承不一样，子类继承父类，并不是把父类的属性方法克隆一份给子类的(这样处理子类和父类就没有关系了)，js中的原型继承是让子类和父类建立原型链接的机制，子类的实例调取父类原型上的方法，都是基于原型链的查找机制完成的；
        存在问题：子类可以重写父类原型上的方法（重写），子类和父类还有关系的
        eg：B.prototype.__proto__.getX = null;  //=>把父类A的原型上的getX重写为null，A的其他实例也会受到影响

        原型继承存在的问题：1.父类实例私有的属性以及公有的属性都变为子类实例的公有属性；2.如果子类B的原型上之前有属性方法，重新指向A的实例后，之前的方法都没有了
    ```
    ```call继承:把父类A作为普通函数执行，让A中的this变为B的实例，相当于给B的实例增加一些属性和方法（弊端：把父类A当做普通函数执行，和父类原型没有啥关系了，仅仅是把A中的私有属性变成子类B实例的私有属性而已，A原型上的公有属性方法和B以及他的实例没有啥关系）
     // new A()     把A作为类创建它的实例  this=>实例
     // A()  把A作为普通函数执行   this=>window
        function A(){
            this.x = 100;    //=>  f.x = 100
        }
        A.prototype = {
            constructor:A,
            getX:function(){
                console.log(this.x)
            }
        };
        function B(){
            //=>this指向f
            A.call(this);   //=>call继承  把A执行，让A中的this变成f
            this.y = 200;
        }
        let f = new B()
    ```
    ```寄生组合继承
        function A(){
            this.x = 100;   
        }
        A.prototype = {
            constructor:A,
            getX:function(){
                console.log(this.x)
            }
        };
        function B(){
            A.call(this);   //=>基于call继承把A的私有变为B的私有
            this.y = 200;
        }
        //  B.prototype = A.prototype;  //弊端：重写更加严重，可以轻易修改父类的属性，会导致A的其他实例也受到影响，所以不这样做
        B.prototype = Object.create(A.prototype);
        let f = new B()

    ```
    ```object.create
        object.create:内置Object类天生自带的方法
        1.创建一个空对象
        2.让新创建的空对象的__proto__指向第一个传递进来的对象(把OBJ作为新创建空对象的原型)

        let obj = {
            name:'Haha'
        }
        console.log(Object.create(obj))
    ```

